diff -uprN libslave-future/CMakeLists.txt libslave/CMakeLists.txt
--- libslave-future/CMakeLists.txt  2012-01-31 05:56:20.000000000 -0800
+++ libslave/CMakeLists.txt	2013-04-22 00:17:37.000000000 -0700
@@ -1,4 +1,4 @@
-CMAKE_MINIMUM_REQUIRED (VERSION 2.8)
+CMAKE_MINIMUM_REQUIRED (VERSION 2.6.1)
 PROJECT (libslave)
 
 # Build flags
diff -uprN libslave-future/CMakeLists.txt.rej libslave/CMakeLists.txt.rej
--- libslave-future/CMakeLists.txt.rej	1969-12-31 16:00:00.000000000 -0800
+++ libslave/CMakeLists.txt.rej	2013-04-22 00:56:18.000000000 -0700
@@ -0,0 +1,43 @@
+***************
+*** 0 ****
+--- 1,40 ----
++ CMAKE_MINIMUM_REQUIRED (VERSION 2.6.1)
++ PROJECT (libslave)
++ 
++ # Build flags
++ IF (CMAKE_COMPILER_IS_GNUCC)
++     # Common options
++     ADD_DEFINITIONS (-pipe)
++     ADD_DEFINITIONS (-Wall)
++     ADD_DEFINITIONS (-O2)
++ ENDIF (CMAKE_COMPILER_IS_GNUCC)
++ 
++ FIND_PACKAGE (Boost REQUIRED)
++ INCLUDE_DIRECTORIES (${Boost_INCLUDE_DIRS})
++ FIND_PACKAGE (Boost 1.41.0 COMPONENTS unit_test_framework thread)
++ 
++ INCLUDE (FindPackageHandleStandardArgs)
++ FIND_PATH (IMYSQL mysql/mysql.h)
++ FIND_LIBRARY (LMYSQLCLIENT_R mysqlclient_r PATH_SUFFIXES mysql)
++ SET (Mysql_FIND_REQUIRED YES)
++ FIND_PACKAGE_HANDLE_STANDARD_ARGS(Mysql DEFAULT_MSG IMYSQL LMYSQLCLIENT_R)
++ INCLUDE_DIRECTORIES ("${IMYSQL}/mysql")
++ 
++ FILE (GLOB HDR "*.h")
++ INSTALL (FILES ${HDR} DESTINATION include)
++ AUX_SOURCE_DIRECTORY (${CMAKE_SOURCE_DIR} SRC)
++ 
++ ADD_LIBRARY (slave_a ${SRC})
++ SET_TARGET_PROPERTIES (slave_a PROPERTIES OUTPUT_NAME slave)
++ TARGET_LINK_LIBRARIES (slave_a ${LMYSQLCLIENT_R})
++ INSTALL (TARGETS slave_a DESTINATION lib64)
++ 
++ ADD_LIBRARY (slave_so SHARED ${SRC})
++ SET_TARGET_PROPERTIES (slave_so PROPERTIES OUTPUT_NAME slave)
++ TARGET_LINK_LIBRARIES (slave_so ${LMYSQLCLIENT_R})
++ INSTALL (TARGETS slave_so DESTINATION lib64)
++ 
++ IF (Boost_FOUND)
++     ENABLE_TESTING ()
++ ENDIF (Boost_FOUND)
++ ADD_SUBDIRECTORY (test)
diff -uprN libslave-future/collate.cpp.rej libslave/collate.cpp.rej
--- libslave-future/collate.cpp.rej	1969-12-31 16:00:00.000000000 -0800
+++ libslave/collate.cpp.rej	2013-04-22 00:56:18.000000000 -0700
@@ -0,0 +1,71 @@
+***************
+*** 0 ****
+--- 1,68 ----
++ #include <map>
++ #include <mysql/mysql.h>
++ #include <stdexcept>
++ #include <stdio.h>
++ #include <string>
++ #include <vector>
++ #include "nanomysql.h"
++ #include "collate.h"
++ 
++ using namespace slave;
++ 
++ collate_map_t slave::readCollateMap(nanomysql::Connection& conn)
++ {
++     collate_map_t res;
++     nanomysql::Connection::result_t nanores;
++ 
++     typedef std::map<std::string, int> charset_maxlen_t;
++     charset_maxlen_t cm;
++ 
++     conn.query("SHOW CHARACTER SET");
++     conn.store(nanores);
++ 
++     for (nanomysql::Connection::result_t::const_iterator i = nanores.begin(); i != nanores.end(); ++i)
++     {
++         std::map<std::string, nanomysql::field>::const_iterator z = i->find("Charset");
++         if (z == i->end())
++             throw std::runtime_error("Slave::readCollateMap(): SHOW CHARACTER SET query did not return 'Charset'");
++         const std::string name = z->second.data;
++ 
++         z = i->find("Maxlen");
++         if (z == i->end())
++             throw std::runtime_error("Slave::readCollateMap(): SHOW CHARACTER SET query did not return 'Maxlen'");
++ 
++         const int maxlen = atoi(z->second.data.c_str());
++ 
++         cm[name] = maxlen;
++     }
++ 
++     nanores.clear();
++     conn.query("SHOW COLLATION");
++     conn.store(nanores);
++ 
++     for (nanomysql::Connection::result_t::const_iterator i = nanores.begin(); i != nanores.end(); ++i)
++     {
++         collate_info ci;
++ 
++         std::map<std::string, nanomysql::field>::const_iterator z = i->find("Collation");
++         if (z == i->end())
++             throw std::runtime_error("Slave::readCollateMap(): SHOW COLLATION query did not return 'Collation'");
++         ci.name = z->second.data;
++ 
++         z = i->find("Charset");
++         if (z == i->end())
++             throw std::runtime_error("Slave::readCollateMap(): SHOW COLLATION query did not return 'Charset'");
++         ci.charset = z->second.data;
++ 
++         charset_maxlen_t::const_iterator j = cm.find(ci.charset);
++         if (j == cm.end())
++             throw std::runtime_error("Slave::readCollateMap(): SHOW COLLATION returns charset not shown in SHOW CHARACTER SET"
++                     " (collation '" + ci.name + "', charset '" + ci.charset + "')");
++ 
++         ci.maxlen = j->second;
++ 
++         res[ci.name] = ci;
++     }
++ 
++     return res;
++ }
diff -uprN libslave-future/collate.h.rej libslave/collate.h.rej
--- libslave-future/collate.h.rej	1969-12-31 16:00:00.000000000 -0800
+++ libslave/collate.h.rej	2013-04-22 00:56:19.000000000 -0700
@@ -0,0 +1,31 @@
+***************
+*** 0 ****
+--- 1,28 ----
++ #ifndef __SLAVE_COLLATE_H
++ #define __SLAVE_COLLATE_H
++ 
++ #include <map>
++ #include <string>
++ 
++ namespace nanomysql
++ {
++     struct Connection;
++ }
++ 
++ namespace slave
++ {
++     struct collate_info
++     {
++         std::string name;
++         std::string charset;
++         int maxlen;
++ 
++         collate_info() : maxlen(0) {}
++     };
++ 
++     typedef std::map<std::string, collate_info> collate_map_t;
++ 
++     collate_map_t readCollateMap(nanomysql::Connection& conn);
++ }// slave
++ 
++ #endif
diff -uprN libslave-future/dec_util.cpp.rej libslave/dec_util.cpp.rej
--- libslave-future/dec_util.cpp.rej	1969-12-31 16:00:00.000000000 -0800
+++ libslave/dec_util.cpp.rej	2013-04-22 00:56:20.000000000 -0700
@@ -0,0 +1,206 @@
+***************
+*** 0 ****
+--- 1,203 ----
++ #include "dec_util.h"
++ 
++ #include <mysql/m_string.h>
++ #include <mysql/my_sys.h>
++ 
++ namespace slave
++ {
++ 
++ namespace dec_util
++ {
++ 
++ 
++ #define DIG_PER_DEC1 9
++ #define DIG_BASE     1000000000
++ #define DIG_MAX      (DIG_BASE-1)
++ 
++ #define mi_sint1korr(A) ((int8)(*A))
++ #define mi_uint1korr(A) ((uint8)(*A))
++ 
++ #define mi_sint2korr(A) ((int16) (((int16) (((uchar*) (A))[1])) +\
++                                   ((int16) ((int16) ((char*) (A))[0]) << 8)))
++ #define mi_sint3korr(A) ((int32) (((((uchar*) (A))[0]) & 128) ? \
++                                   (((uint32) 255L << 24) | \
++                                    (((uint32) ((uchar*) (A))[0]) << 16) |\
++                                    (((uint32) ((uchar*) (A))[1]) << 8) | \
++                                    ((uint32) ((uchar*) (A))[2])) : \
++                                   (((uint32) ((uchar*) (A))[0]) << 16) |\
++                                   (((uint32) ((uchar*) (A))[1]) << 8) | \
++                                   ((uint32) ((uchar*) (A))[2])))
++ #define mi_sint4korr(A) ((int32) (((int32) (((uchar*) (A))[3])) +\
++                                   ((int32) (((uchar*) (A))[2]) << 8) +\
++                                   ((int32) (((uchar*) (A))[1]) << 16) +\
++                                   ((int32) ((int16) ((char*) (A))[0]) << 24)))
++ 
++ #define FIX_INTG_FRAC_ERROR(len, intg1, frac1, error)                   \
++         do                                                              \
++         {                                                               \
++           if (unlikely(intg1+frac1 > (len)))                            \
++           {                                                             \
++             if (unlikely(intg1 > (len)))                                \
++             {                                                           \
++               intg1=(len);                                              \
++               frac1=0;                                                  \
++               error=E_DEC_OVERFLOW;                                     \
++             }                                                           \
++             else                                                        \
++             {                                                           \
++               frac1=(len)-intg1;                                        \
++               error=E_DEC_TRUNCATED;                                    \
++             }                                                           \
++           }                                                             \
++           else                                                          \
++             error=E_DEC_OK;                                             \
++         } while(0)
++ 
++ 
++ static const int dig2bytes[DIG_PER_DEC1+1]={0, 1, 1, 2, 2, 3, 3, 4, 4, 4};
++ static const dec1 powers10[DIG_PER_DEC1+1]={1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000};
++ 
++ static double scaler10[]= {1.0, 1e10, 1e20, 1e30, 1e40, 1e50, 1e60, 1e70, 1e80, 1e90};
++ static double scaler1[]= {1.0, 10.0, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9};
++ 
++ int decimal_bin_size(int precision, int scale)
++ {
++     int intg=precision-scale,
++         intg0=intg/DIG_PER_DEC1, frac0=scale/DIG_PER_DEC1,
++         intg0x=intg-intg0*DIG_PER_DEC1, frac0x=scale-frac0*DIG_PER_DEC1;
++ 
++     DBUG_ASSERT(scale >= 0 && precision > 0 && scale <= precision);
++     return intg0*sizeof(dec1)+dig2bytes[intg0x]+
++         frac0*sizeof(dec1)+dig2bytes[frac0x];
++ }
++ 
++ int bin2dec(const char *from, decimal_t *to, int precision, int scale)
++ {
++     int error=E_DEC_OK, intg=precision-scale,
++             intg0=intg/DIG_PER_DEC1, frac0=scale/DIG_PER_DEC1,
++             intg0x=intg-intg0*DIG_PER_DEC1, frac0x=scale-frac0*DIG_PER_DEC1,
++             intg1=intg0+(intg0x>0), frac1=frac0+(frac0x>0);
++     dec1 *buf=to->buf, mask=(*from & 0x80) ? 0 : -1;
++     const char *stop;
++     char *d_copy;
++     int bin_size= decimal_bin_size(precision, scale);
++ 
++     //sanity(to);
++     d_copy= (char*) my_alloca(bin_size);
++     memcpy(d_copy, from, bin_size);
++     d_copy[0]^= 0x80;
++     from= d_copy;
++ 
++     FIX_INTG_FRAC_ERROR(to->len, intg1, frac1, error);
++     if (unlikely(error))
++     {
++         if (intg1 < intg0+(intg0x>0))
++         {
++             from+=dig2bytes[intg0x]+sizeof(dec1)*(intg0-intg1);
++             frac0=frac0x=intg0x=0;
++             intg0=intg1;
++         }
++         else
++         {
++             frac0x=0;
++             frac0=frac1;
++         }
++     }
++ 
++     to->sign=(mask != 0);
++     to->intg=intg0*DIG_PER_DEC1+intg0x;
++     to->frac=frac0*DIG_PER_DEC1+frac0x;
++ 
++     if (intg0x)
++     {
++         int i=dig2bytes[intg0x];
++         dec1 x; //UNINIT_VAR(x);
++         switch (i)
++         {
++             case 1: x=mi_sint1korr(from); break;
++             case 2: x=mi_sint2korr(from); break;
++             case 3: x=mi_sint3korr(from); break;
++             case 4: x=mi_sint4korr(from); break;
++             default: DBUG_ASSERT(0);
++         }
++         from+=i;
++         *buf=x ^ mask;
++         if (((ulonglong)*buf) >= (ulonglong) powers10[intg0x+1])
++             goto err;
++         if (buf > to->buf || *buf != 0)
++             buf++;
++         else
++             to->intg-=intg0x;
++     }
++     for (stop=from+intg0*sizeof(dec1); from < stop; from+=sizeof(dec1))
++     {
++         DBUG_ASSERT(sizeof(dec1) == 4);
++         *buf=mi_sint4korr(from) ^ mask;
++         if (((uint32)*buf) > DIG_MAX)
++             goto err;
++         if (buf > to->buf || *buf != 0)
++             buf++;
++         else
++             to->intg-=DIG_PER_DEC1;
++     }
++     DBUG_ASSERT(to->intg >=0);
++     for (stop=from+frac0*sizeof(dec1); from < stop; from+=sizeof(dec1))
++     {
++         DBUG_ASSERT(sizeof(dec1) == 4);
++         *buf=mi_sint4korr(from) ^ mask;
++         if (((uint32)*buf) > DIG_MAX)
++             goto err;
++         buf++;
++     }
++     if (frac0x)
++     {
++         int i=dig2bytes[frac0x];
++         dec1 x; //UNINIT_VAR(x);
++         switch (i)
++         {
++             case 1: x=mi_sint1korr(from); break;
++             case 2: x=mi_sint2korr(from); break;
++             case 3: x=mi_sint3korr(from); break;
++             case 4: x=mi_sint4korr(from); break;
++             default: DBUG_ASSERT(0);
++         }
++         *buf=(x ^ mask) * powers10[DIG_PER_DEC1 - frac0x];
++         if (((uint32)*buf) > DIG_MAX)
++             goto err;
++         buf++;
++     }
++     my_afree(d_copy);
++ 
++     if (to->intg == 0 && to->frac == 0)
++         decimal_make_zero(to);
++     return error;
++ 
++ err:
++     my_afree(d_copy);
++     decimal_make_zero(to);
++     return(E_DEC_BAD_NUM);
++ }
++ 
++ void dec2dbl(decimal_t *from, double *to)
++ {
++     double result= 0.0;
++     int i, exp= 0;
++     dec1 *buf= from->buf;
++ 
++     for (i= from->intg; i > 0; i-= DIG_PER_DEC1)
++         result= result * DIG_BASE + *buf++;
++ 
++     for (i= from->frac; i > 0; i-= DIG_PER_DEC1) {
++         result= result * DIG_BASE + *buf++;
++         exp+= DIG_PER_DEC1;
++     }
++ 
++     result/= scaler10[exp / 10] * scaler1[exp % 10];
++ 
++     *to= from->sign ? -result : result;
++ }
++ 
++ 
++ } // namespace dec_util
++ 
++ } // namespace slave
diff -uprN libslave-future/dec_util.h.rej libslave/dec_util.h.rej
--- libslave-future/dec_util.h.rej	1969-12-31 16:00:00.000000000 -0800
+++ libslave/dec_util.h.rej	2013-04-22 00:56:21.000000000 -0700
@@ -0,0 +1,91 @@
+***************
+*** 0 ****
+--- 1,88 ----
++ #ifndef __SLAVE_DEC_UTIL_H_
++ #define __SLAVE_DEC_UTIL_H_
++ 
++ /*
++     for storage decimal numbers are converted to the "binary" format.
++ 
++     This format has the following properties:
++       1. length of the binary representation depends on the {precision, scale}
++       as provided by the caller and NOT on the intg/frac of the decimal to
++       convert.
++       2. binary representations of the same {precision, scale} can be compared
++       with memcmp - with the same result as decimal_cmp() of the original
++       decimals (not taking into account possible precision loss during
++       conversion).
++ 
++     This binary format is as follows:
++       1. First the number is converted to have a requested precision and scale.
++       2. Every full DIG_PER_DEC1 digits of intg part are stored in 4 bytes
++          as is
++       3. The first intg % DIG_PER_DEC1 digits are stored in the reduced
++          number of bytes (enough bytes to store this number of digits -
++          see dig2bytes)
++       4. same for frac - full decimal_digit_t's are stored as is,
++          the last frac % DIG_PER_DEC1 digits - in the reduced number of bytes.
++       5. If the number is negative - every byte is inversed.
++       5. The very first bit of the resulting byte array is inverted (because
++          memcmp compares unsigned bytes, see property 2 above)
++ 
++     Example:
++ 
++       1234567890.1234
++ 
++     internally is represented as 3 decimal_digit_t's
++ 
++       1 234567890 123400000
++ 
++     (assuming we want a binary representation with precision=14, scale=4)
++     in hex it's
++ 
++       00-00-00-01  0D-FB-38-D2  07-5A-EF-40
++ 
++     now, middle decimal_digit_t is full - it stores 9 decimal digits. It goes
++     into binary representation as is:
++ 
++ 
++       ...........  0D-FB-38-D2 ............
++ 
++     First decimal_digit_t has only one decimal digit. We can store one digit in
++     one byte, no need to waste four:
++ 
++                 01 0D-FB-38-D2 ............
++ 
++     now, last digit. It's 123400000. We can store 1234 in two bytes:
++ 
++                 01 0D-FB-38-D2 04-D2
++ 
++     So, we've packed 12 bytes number in 7 bytes.
++     And now we invert the highest bit to get the final result:
++ 
++                 81 0D FB 38 D2 04 D2
++ 
++     And for -1234567890.1234 it would be
++ 
++                 7E F2 04 37 2D FB 2D
++ */
++ 
++ #include <mysql/my_global.h>
++ #include <mysql/decimal.h>
++ 
++ namespace slave
++ {
++ 
++ namespace dec_util
++ {
++ 
++ typedef decimal_digit_t dec1;
++ 
++ // converts from raw const char* to internal MySql type decimal_t
++ int bin2dec(const char *from, decimal_t *to, int precision, int scale);
++ 
++ // converts from internal MySql type decimal_t to double
++ void dec2dbl(decimal_t *from, double *to);
++ 
++ } // namespace dec_util
++ 
++ } // namespace slave
++ 
++ #endif
diff -uprN libslave-future/field.cpp.rej libslave/field.cpp.rej
--- libslave-future/field.cpp.rej	1969-12-31 16:00:00.000000000 -0800
+++ libslave/field.cpp.rej	2013-04-22 00:56:22.000000000 -0700
@@ -0,0 +1,445 @@
+***************
+*** 0 ****
+--- 1,442 ----
++ /* Copyright 2011 ZAO "Begun".
++  *
++  * This library is free software; you can redistribute it and/or modify it under
++  * the terms of the GNU Lesser General Public License as published by the Free
++  * Software Foundation; either version 3 of the License, or (at your option)
++  * any later version.
++  * This library is distributed in the hope that it will be useful, but WITHOUT
++  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
++  * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
++  * details.
++  * You should have received a copy of the GNU Lesser General Public License
++  * along with this library.  If not, see <http://www.gnu.org/licenses/>.
++ */
++ 
++ 
++ #include <cstdio>
++ #include <vector>
++ #include <stdexcept>                                                                                                                
++ #include <mysql/my_global.h>
++ #undef min
++ #undef max
++ 
++ #include <mysql/m_string.h>
++ 
++ #include "dec_util.h"
++ #include "field.h"
++ 
++ #include "Logging.h"
++ 
++ 
++ 
++ 
++ namespace slave
++ {
++ 
++ 
++ 
++ Field_num::Field_num(const std::string& field_name_arg, const std::string& type):
++     Field(field_name_arg, type) {}
++ 
++ Field_tiny::Field_tiny(const std::string& field_name_arg, const std::string& type):
++     Field_num(field_name_arg, type) {}
++ 
++ const char* Field_tiny::unpack(const char* from) {
++ 
++     char tmp = *((char*)(from));
++     field_data = tmp;
++ 
++     LOG_TRACE(log, "  tiny: " << (int)(tmp) << " // " << pack_length());
++ 
++     return from + pack_length();
++ }
++ 
++ 
++ Field_short::Field_short(const std::string& field_name_arg, const std::string& type):
++     Field_num(field_name_arg, type) {}
++ 
++ const char* Field_short::unpack(const char* from) {
++ 
++     uint16 tmp = uint2korr(from);
++     field_data = tmp;
++ 
++     LOG_TRACE(log, "  short: " << tmp << " // " << pack_length());
++ 
++     return from + pack_length();
++ }
++ 
++ Field_medium::Field_medium(const std::string& field_name_arg, const std::string& type):
++     Field_num(field_name_arg, type) {}
++ 
++ const char* Field_medium::unpack(const char* from) {
++ 
++     uint32 tmp = uint3korr(from);
++     field_data = tmp;
++ 
++     LOG_TRACE(log, "  medium: " << tmp << " // " << pack_length());
++ 
++     return from + pack_length();
++ }
++ 
++ Field_long::Field_long(const std::string& field_name_arg, const std::string& type):
++     Field_num(field_name_arg, type) {}
++ 
++ const char* Field_long::unpack(const char* from) {
++ 
++     uint32 tmp = uint4korr(from);
++     field_data = tmp;
++ 
++     LOG_TRACE(log, "  long: " << tmp << " // " << pack_length());
++ 
++     return from + pack_length();
++ }
++ 
++ Field_longlong::Field_longlong(const std::string& field_name_arg, const std::string& type):
++     Field_num(field_name_arg, type) {}
++ 
++ const char* Field_longlong::unpack(const char* from) {
++ 
++     ulonglong tmp = uint8korr(from);
++     field_data = tmp;
++ 
++     LOG_TRACE(log, "  longlong: " << tmp << " // " << pack_length());
++ 
++     return from + pack_length();
++ }
++ 
++ Field_real::Field_real(const std::string& field_name_arg, const std::string& type):
++     Field_num(field_name_arg, type) {}
++ 
++ Field_double::Field_double(const std::string& field_name_arg, const std::string& type):
++     Field_real(field_name_arg, type) {}
++ 
++ const char* Field_double::unpack(const char* from) {
++ 
++     double tmp = *((double*)(from));
++     field_data = tmp;
++ 
++     LOG_TRACE(log, "  double: " << tmp << " // " << pack_length());
++ 
++     return from + pack_length();
++ }
++ 
++ 
++ Field_float::Field_float(const std::string& field_name_arg, const std::string& type):
++     Field_real(field_name_arg, type) {}
++ 
++ const char* Field_float::unpack(const char* from) {
++ 
++     float tmp = *((float*)(from));
++     field_data = tmp;
++ 
++     LOG_TRACE(log, "  float: " << tmp << " // " << pack_length());
++ 
++     return from + pack_length();
++ }
++ 
++ 
++ Field_str::Field_str(const std::string& field_name_arg, const std::string& type):
++     Field(field_name_arg, type) {}
++ 
++ Field_timestamp::Field_timestamp(const std::string& field_name_arg, const std::string& type):
++     Field_str(field_name_arg, type) {}
++ 
++ const char* Field_timestamp::unpack(const char* from) {
++ 
++     uint32 tmp = uint4korr(from);
++     field_data = tmp;
++ 
++     LOG_TRACE(log, "  timestamp: " << tmp << " // " << pack_length());
++ 
++     return from + pack_length();
++ }
++ 
++ Field_year::Field_year(const std::string& field_name_arg, const std::string& type):
++     Field_tiny(field_name_arg, type) {}
++ 
++ Field_datetime::Field_datetime(const std::string& field_name_arg, const std::string& type):
++     Field_str(field_name_arg, type) {}
++ 
++ const char* Field_datetime::unpack(const char* from) {
++ 
++     ulonglong tmp = uint8korr(from);
++     field_data = tmp;
++ 
++     LOG_TRACE(log, "  datetime: " << tmp << " // " << pack_length());
++ 
++     return from + pack_length();
++ }
++ 
++ Field_date::Field_date(const std::string& field_name_arg, const std::string& type):
++     Field_str(field_name_arg, type) {}
++ 
++ const char* Field_date::unpack(const char* from) {
++ 
++     uint32 tmp = uint3korr(from);
++     field_data = tmp;
++ 
++     LOG_TRACE(log, "  date: " << tmp << " // " << pack_length());
++ 
++     return from + pack_length();
++ }
++ 
++ Field_time::Field_time(const std::string& field_name_arg, const std::string& type):
++     Field_str(field_name_arg, type) {}
++ 
++ const char* Field_time::unpack(const char* from) {
++ 
++     uint32 tmp = uint3korr(from);
++     field_data = tmp;
++ 
++     LOG_TRACE(log, "  time: " << tmp << " // " << pack_length());
++ 
++     return from + pack_length();
++ }
++ 
++ Field_enum::Field_enum(const std::string& field_name_arg, const std::string& type):
++     Field_str(field_name_arg, type) {
++ 
++     // for fields of type 'enum' the number of elements needs to be counted
++     // if the number of elements is less than 255, then this type has a size of 1 byte
++     count_elements = 1;
++     for (std::string::const_iterator i = type.begin(); i != type.end(); ++i) {
++         if (*i == ',') {
++             count_elements++;
++         }
++     }
++ }
++ 
++ const char* Field_enum::unpack(const char* from) {
++ 
++     int tmp;
++ 
++     if (pack_length() == 1) {
++ 
++         tmp = int(*((char*)(from)));
++ 
++     } else {
++         tmp = int(*((short*)(from)));
++     }
++ 
++     field_data = tmp;
++ 
++     LOG_TRACE(log, "  enum: " << tmp << " // " << pack_length());
++ 
++     return from + pack_length();
++ }
++ 
++ Field_set::Field_set(const std::string& field_name_arg, const std::string& type):
++     Field_enum(field_name_arg, type) {
++ 
++     // for fields of type 'enum' the number of elements needs to be counted
++     // the formula for determining size is (N+7)/8
++ 
++     count_elements = 1;
++     for (std::string::const_iterator i = type.begin(); i != type.end(); ++i) {
++         if (*i == ',') {
++             count_elements++;
++         }
++     }
++ }
++ 
++ const char* Field_set::unpack(const char* from) {
++     ulonglong tmp;
++ 
++     switch(pack_length()) {
++     case 1:
++         tmp = ulonglong(*((char*)(from)));
++         break;
++     case 2:
++         tmp = ulonglong(uint2korr(from));
++         break;
++     case 3:
++         tmp = ulonglong(uint3korr(from));
++         break;
++     case 4:
++         tmp = ulonglong(uint4korr(from));
++         break;
++     case 8:
++         tmp = uint8korr(from);
++         break;
++     default:
++         tmp = uint8korr(from);
++         break;
++     }
++ 
++     field_data = tmp;
++ 
++     LOG_TRACE(log, "  set: " << tmp << " // " << pack_length());
++ 
++     return from + pack_length();
++ }
++ 
++ Field_longstr::Field_longstr(const std::string& field_name_arg, const std::string& type):
++     Field_str(field_name_arg, type)  {}
++ 
++ Field_varstring::Field_varstring(const std::string& field_name_arg, const std::string& type, const collate_info& collate):
++     Field_longstr(field_name_arg, type) {
++ 
++     // field size is determined by string type capacity
++ 
++     std::string::size_type b = type.find('(', 0);
++     std::string::size_type e = type.find(')', 0);
++ 
++     if (b == std::string::npos || e == std::string::npos) {
++         throw std::runtime_error("Field_string: Incorrect field VARCHAR");
++     }
++ 
++     std::string str_count(type, b+1, e-b-1); 
++     int symbols = atoi(str_count.c_str());
++     int bytes = symbols * collate.maxlen;
++ 
++     // number of bytes for holding the length
++     length_bytes = ((bytes < 256) ? 1 : 2);
++ 	
++     // max length of string
++     field_length = symbols;
++ }
++ 
++ const char* Field_varstring::unpack(const char* from) {
++ 
++     unsigned length_row;
++     if (length_bytes == 1) {
++         //length_row = (unsigned int) (unsigned char) (*to = *from++);
++         length_row = (unsigned int) (unsigned char) (*from++);
++ 
++     } else {
++         length_row = uint2korr(from);
++         from++;
++         from++;
++     }
++ 
++     std::string tmp(from, length_row);
++ 
++     field_data = tmp;
++ 
++     LOG_TRACE(log, "  varstr: '" << tmp << "' // " << length_bytes << " " << length_row);
++ 
++     return from + length_row;
++ }
++ 
++ 
++ Field_blob::Field_blob(const std::string& field_name_arg, const std::string& type):
++     Field_longstr(field_name_arg, type), packlength(2) {}
++ 
++ Field_tinyblob::Field_tinyblob(const std::string& field_name_arg, const std::string& type):
++     Field_blob(field_name_arg, type) { packlength = 1; }
++ 
++ Field_mediumblob::Field_mediumblob(const std::string& field_name_arg, const std::string& type):
++     Field_blob(field_name_arg, type) { packlength = 3; }
++ 
++ Field_longblob::Field_longblob(const std::string& field_name_arg, const std::string& type):
++     Field_blob(field_name_arg, type) { packlength = 4; }
++ 
++ const char* Field_blob::unpack(const char* from) {
++ 
++     const unsigned length_row = get_length(from);
++     from += packlength;
++ 
++     std::string tmp(from, length_row);
++ 
++     field_data = tmp;
++ 
++     LOG_TRACE(log, "  blob: '" << tmp << "' // " << packlength << " " << length_row);
++ 
++     return from + length_row;
++ }
++ 
++ 
++ unsigned int Field_blob::get_length(const char *pos) {
++ 
++     switch (packlength)
++     {
++     case 1:
++         return (unsigned int) (unsigned char) pos[0];
++     case 2:
++     {
++ 
++         unsigned short tmp = 0;
++ 
++         /*
++         if (db_low_byte_first) {
++             tmp = sint2korr(pos);
++         } else {
++             shortget(tmp,pos);
++         }
++         */
++         tmp = sint2korr(pos);
++     			
++         return (unsigned int) tmp;
++ 
++     }
++     case 3:
++         return (unsigned int) uint3korr(pos);
++     case 4:
++     {
++         unsigned int tmp;
++ 
++         /*
++         if (db_low_byte_first)
++             tmp = uint4korr(pos);
++         else
++             longget(tmp,pos);
++         */
++         tmp = uint4korr(pos);
++ 
++         return (unsigned int) tmp;
++     }
++ 
++     }
++ 
++     throw std::runtime_error("Oops, wrong packlength in Field_blob::get_length(): wanted 1, 2, 3 or 4.");
++ }
++ 
++ Field_decimal::Field_decimal(const std::string& field_name_arg, const std::string& type):
++     Field_longstr(field_name_arg, type),
++     intg(0),
++     frac(0)
++ {
++     // Получаем размеры поля: decimal(M,D)
++     // M - общее количество цифр, M-D - до запятой
++ 
++     const std::string::size_type b = type.find('(', 0);
++ 
++     if (b == std::string::npos) {
++         throw std::runtime_error("Field_string: Incorrect field DECIMAL");
++     }
++ 
++     int m, d;
++     if (2 != sscanf(type.c_str() + b, "(%d,%d)", &m, &d) || m <= 0 || m < d) {
++         throw std::runtime_error("Field_string: Incorrect field DECIMAL");
++     }
++ 
++     intg = m - d;
++     frac = d;
++ 
++     static const int dig2bytes[] = {0, 1, 1, 2, 2, 3, 3, 4, 4, 4};
++     field_length = (intg / 9) * 4 + dig2bytes[intg % 9] + (frac / 9) * 4 + dig2bytes[frac % 9];
++ }
++ 
++ const char* Field_decimal::unpack(const char *from)
++ {
++     double result = dec2double(from);
++     field_data = result;
++     return from + pack_length();
++ }
++ 
++ double Field_decimal::dec2double(const char* from)
++ {
++     decimal_t val;
++     val.len = intg + frac;
++     size_t bytes = val.len * sizeof(decimal_digit_t);
++     val.buf = (decimal_digit_t *)alloca(bytes);
++     memset(val.buf, 0, bytes);
++ 
++     dec_util::bin2dec(from, &val, intg+frac, frac);
++     double v = 0;
++     dec_util::dec2dbl(&val, &v);
++ 
++     return v;
++ }
++ 
++ } // namespace slave
diff -uprN libslave-future/nova_global.h libslave/nova_global.h
--- libslave-future/nova_global.h	1969-12-31 16:00:00.000000000 -0800
+++ libslave/nova_global.h	2013-04-22 00:43:58.000000000 -0700
@@ -0,0 +1,1481 @@
+/*
+   Copyright (c) 2001, 2011, Oracle and/or its affiliates. All rights reserved.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 of the License.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
+
+/* This is the include file that should be included 'first' in every C file. */
+
+#ifndef _nova_global_h
+#define _nova_global_h
+
+/* Client library users on Windows need this macro defined here. */
+#if !defined(__WIN__) && defined(_WIN32)
+#define __WIN__
+#endif
+
+/*
+  InnoDB depends on some MySQL internals which other plugins should not
+  need.  This is because of InnoDB's foreign key support, "safe" binlog
+  truncation, and other similar legacy features.
+
+  We define accessors for these internals unconditionally, but do not
+  expose them in mysql/plugin.h.  They are declared in ha_innodb.h for
+  InnoDB's use.
+*/
+#define INNODB_COMPATIBILITY_HOOKS
+
+#ifdef __CYGWIN__
+/* We use a Unix API, so pretend it's not Windows */
+#undef WIN
+#undef WIN32
+#undef _WIN
+#undef _WIN32
+#undef _WIN64
+#undef __WIN__
+#undef __WIN32__
+#define HAVE_ERRNO_AS_DEFINE
+#endif /* __CYGWIN__ */
+
+/* to make command line shorter we'll define USE_PRAGMA_INTERFACE here */
+#ifdef USE_PRAGMA_IMPLEMENTATION
+#define USE_PRAGMA_INTERFACE
+#endif
+
+#if defined(__OpenBSD__) && (OpenBSD >= 200411)
+#define HAVE_ERRNO_AS_DEFINE
+#endif
+
+#if defined(i386) && !defined(__i386__)
+#define __i386__
+#endif
+
+/* Macros to make switching between C and C++ mode easier */
+#ifdef __cplusplus
+#define C_MODE_START    extern "C" {
+#define C_MODE_END	}
+#else
+#define C_MODE_START
+#define C_MODE_END
+#endif
+
+#ifdef __cplusplus
+#define CPP_UNNAMED_NS_START  namespace {
+#define CPP_UNNAMED_NS_END    }
+#endif
+
+#include <my_config.h>
+
+#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE
+#define HAVE_PSI_INTERFACE
+#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */
+
+/* Make it easier to add conditional code in _expressions_ */
+#ifdef __WIN__
+#define IF_WIN(A,B) A
+#else
+#define IF_WIN(A,B) B
+#endif
+
+#ifdef HAVE_purify
+#define IF_PURIFY(A,B) A
+#else
+#define IF_PURIFY(A,B) B
+#endif
+
+#ifndef EMBEDDED_LIBRARY
+#ifdef WITH_NDB_BINLOG
+#define HAVE_NDB_BINLOG 1
+#endif
+#endif /* !EMBEDDED_LIBRARY */
+
+#ifndef EMBEDDED_LIBRARY
+#define HAVE_REPLICATION
+#define HAVE_EXTERNAL_CLIENT
+#endif
+
+#if defined (_WIN32)
+/*
+ off_t is 32 bit long. We do not use C runtime functions
+ with off_t but native Win32 file IO APIs, that work with
+ 64 bit offsets.
+*/
+#undef SIZEOF_OFF_T
+#define SIZEOF_OFF_T 8
+
+/*
+ Prevent inclusion of  Windows GDI headers - they define symbol
+ ERROR that conflicts with mysql headers.
+*/
+#ifndef NOGDI
+#define NOGDI
+#endif
+
+/* Include common headers.*/
+#include <winsock2.h>
+#include <ws2tcpip.h> /* SOCKET */
+#include <io.h>       /* access(), chmod() */
+#include <process.h>  /* getpid() */
+
+#define sleep(a) Sleep((a)*1000)
+
+/* Define missing access() modes. */
+#define F_OK 0
+#define W_OK 2
+
+/* Define missing file locking constants. */
+#define F_RDLCK 1
+#define F_WRLCK 2
+#define F_UNLCK 3
+#define F_TO_EOF 0x3FFFFFFF
+
+/* Shared memory and named pipe connections are supported. */
+#define HAVE_SMEM 1
+#define HAVE_NAMED_PIPE 1
+#define shared_memory_buffer_length 16000
+#define default_shared_memory_base_name "MYSQL"
+#endif /* _WIN32*/
+
+
+/* Workaround for _LARGE_FILES and _LARGE_FILE_API incompatibility on AIX */
+#if defined(_AIX) && defined(_LARGE_FILE_API)
+#undef _LARGE_FILE_API
+#endif
+
+/*
+  The macros below are used to allow build of Universal/fat binaries of
+  MySQL and MySQL applications under darwin. 
+*/
+#if defined(__APPLE__) && defined(__MACH__)
+#  undef SIZEOF_CHARP 
+#  undef SIZEOF_SHORT 
+#  undef SIZEOF_INT 
+#  undef SIZEOF_LONG 
+#  undef SIZEOF_LONG_LONG 
+#  undef SIZEOF_OFF_T 
+#  undef WORDS_BIGENDIAN
+#  define SIZEOF_SHORT 2
+#  define SIZEOF_INT 4
+#  define SIZEOF_LONG_LONG 8
+#  define SIZEOF_OFF_T 8
+#  if defined(__i386__) || defined(__ppc__)
+#    define SIZEOF_CHARP 4
+#    define SIZEOF_LONG 4
+#  elif defined(__x86_64__) || defined(__ppc64__)
+#    define SIZEOF_CHARP 8
+#    define SIZEOF_LONG 8
+#  else
+#    error Building FAT binary for an unknown architecture.
+#  endif
+#  if defined(__ppc__) || defined(__ppc64__)
+#    define WORDS_BIGENDIAN
+#  endif
+#endif /* defined(__APPLE__) && defined(__MACH__) */
+
+
+/*
+  The macros below are borrowed from include/linux/compiler.h in the
+  Linux kernel. Use them to indicate the likelyhood of the truthfulness
+  of a condition. This serves two purposes - newer versions of gcc will be
+  able to optimize for branch predication, which could yield siginficant
+  performance gains in frequently executed sections of the code, and the
+  other reason to use them is for documentation
+*/
+
+#if !defined(__GNUC__) || (__GNUC__ == 2 && __GNUC_MINOR__ < 96)
+#define __builtin_expect(x, expected_value) (x)
+#endif
+
+#define likely(x)	__builtin_expect((x),1)
+#define unlikely(x)	__builtin_expect((x),0)
+
+/* Fix problem with S_ISLNK() on Linux */
+#if defined(TARGET_OS_LINUX) || defined(__GLIBC__)
+#undef  _GNU_SOURCE
+#define _GNU_SOURCE 1
+#endif
+
+/*
+  Temporary solution to solve bug#7156. Include "sys/types.h" before
+  the thread headers, else the function madvise() will not be defined
+*/
+#if defined(HAVE_SYS_TYPES_H) && ( defined(sun) || defined(__sun) )
+#include <sys/types.h>
+#endif
+
+#ifdef HAVE_THREADS_WITHOUT_SOCKETS
+/* MIT pthreads does not work with unix sockets */
+#undef HAVE_SYS_UN_H
+#endif
+
+#define __EXTENSIONS__ 1	/* We want some extension */
+#ifndef __STDC_EXT__
+#define __STDC_EXT__ 1          /* To get large file support on hpux */
+#endif
+
+/*
+  Solaris 9 include file <sys/feature_tests.h> refers to X/Open document
+
+    System Interfaces and Headers, Issue 5
+
+  saying we should define _XOPEN_SOURCE=500 to get POSIX.1c prototypes,
+  but apparently other systems (namely FreeBSD) don't agree.
+
+  On a newer Solaris 10, the above file recognizes also _XOPEN_SOURCE=600.
+  Furthermore, it tests that if a program requires older standard
+  (_XOPEN_SOURCE<600 or _POSIX_C_SOURCE<200112L) it cannot be
+  run on a new compiler (that defines _STDC_C99) and issues an #error.
+  It's also an #error if a program requires new standard (_XOPEN_SOURCE=600
+  or _POSIX_C_SOURCE=200112L) and a compiler does not define _STDC_C99.
+
+  To add more to this mess, Sun Studio C compiler defines _STDC_C99 while
+  C++ compiler does not!
+
+  So, in a desperate attempt to get correct prototypes for both
+  C and C++ code, we define either _XOPEN_SOURCE=600 or _XOPEN_SOURCE=500
+  depending on the compiler's announced C standard support.
+
+  Cleaner solutions are welcome.
+*/
+#ifdef __sun
+#if __STDC_VERSION__ - 0 >= 199901L
+#define _XOPEN_SOURCE 600
+#else
+#define _XOPEN_SOURCE 500
+#endif
+#endif
+
+#if !defined(__WIN__)
+#ifndef _POSIX_PTHREAD_SEMANTICS
+#define _POSIX_PTHREAD_SEMANTICS /* We want posix threads */
+#endif
+
+#if !defined(SCO)
+#define _REENTRANT	1	/* Some thread libraries require this */
+#endif
+#if !defined(_THREAD_SAFE) && !defined(_AIX)
+#define _THREAD_SAFE            /* Required for OSF1 */
+#endif
+#if defined(HPUX10) || defined(HPUX11)
+C_MODE_START			/* HPUX needs this, signal.h bug */
+#include <pthread.h>
+C_MODE_END
+#else
+#include <pthread.h>		/* AIX must have this included first */
+#endif
+#if !defined(SCO) && !defined(_REENTRANT)
+#define _REENTRANT	1	/* Threads requires reentrant code */
+#endif
+#endif /* !defined(__WIN__) */
+
+/* Go around some bugs in different OS and compilers */
+#ifdef _AIX			/* By soren@t.dk */
+#define _H_STRINGS
+#define _SYS_STREAM_H
+/* #define _AIX32_CURSES */	/* XXX: this breaks AIX 4.3.3 (others?). */
+#define ulonglong2double(A) my_ulonglong2double(A)
+#define my_off_t2double(A)  my_ulonglong2double(A)
+C_MODE_START
+inline double my_ulonglong2double(unsigned long long A) { return (double A); }
+C_MODE_END
+#endif /* _AIX */
+
+#ifdef HAVE_BROKEN_SNPRINTF	/* HPUX 10.20 don't have this defined */
+#undef HAVE_SNPRINTF
+#endif
+#ifdef HAVE_BROKEN_PREAD
+/*
+  pread()/pwrite() are not 64 bit safe on HP-UX 11.0 without
+  installing the kernel patch PHKL_20349 or greater
+*/
+#undef HAVE_PREAD
+#undef HAVE_PWRITE
+#endif
+
+#ifdef UNDEF_HAVE_INITGROUPS			/* For AIX 4.3 */
+#undef HAVE_INITGROUPS
+#endif
+
+/* gcc/egcs issues */
+
+#if defined(__GNUC) && defined(__EXCEPTIONS)
+#error "Please add -fno-exceptions to CXXFLAGS and reconfigure/recompile"
+#endif
+
+#if defined(_lint) && !defined(lint)
+#define lint
+#endif
+#if SIZEOF_LONG_LONG > 4 && !defined(_LONG_LONG)
+#define _LONG_LONG 1		/* For AIX string library */
+#endif
+
+#ifndef stdin
+#include <stdio.h>
+#endif
+#include <stdarg.h>
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#ifdef HAVE_STDDEF_H
+#include <stddef.h>
+#endif
+
+#include <math.h>
+#ifdef HAVE_LIMITS_H
+#include <limits.h>
+#endif
+#ifdef HAVE_FLOAT_H
+#include <float.h>
+#endif
+#ifdef HAVE_FENV_H
+#include <fenv.h> /* For fesetround() */
+#endif
+
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_FCNTL_H
+#include <fcntl.h>
+#endif
+#ifdef HAVE_SYS_TIMEB_H
+#include <sys/timeb.h>				/* Avoid warnings on SCO */
+#endif
+#if TIME_WITH_SYS_TIME
+# include <sys/time.h>
+# include <time.h>
+#else
+# if HAVE_SYS_TIME_H
+#  include <sys/time.h>
+# else
+#  include <time.h>
+# endif
+#endif /* TIME_WITH_SYS_TIME */
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#if defined(__cplusplus) && defined(NO_CPLUSPLUS_ALLOCA)
+#undef HAVE_ALLOCA
+#undef HAVE_ALLOCA_H
+#endif
+#ifdef HAVE_ALLOCA_H
+#include <alloca.h>
+#endif
+
+#include <errno.h>				/* Recommended by debian */
+/* We need the following to go around a problem with openssl on solaris */
+#if defined(HAVE_CRYPT_H)
+#include <crypt.h>
+#endif
+
+/*
+  A lot of our programs uses asserts, so better to always include it
+  This also fixes a problem when people uses DBUG_ASSERT without including
+  assert.h
+*/
+#include <assert.h>
+
+/* an assert that works at compile-time. only for constant expression */
+#ifndef __GNUC__
+#define compile_time_assert(X)  do { } while(0)
+#else
+#define compile_time_assert(X)                                  \
+  do                                                            \
+  {                                                             \
+    typedef char compile_time_assert[(X) ? 1 : -1];             \
+  } while(0)
+#endif
+
+/* Go around some bugs in different OS and compilers */
+#if defined (HPUX11) && defined(_LARGEFILE_SOURCE)
+#ifndef _LARGEFILE64_SOURCE
+#define _LARGEFILE64_SOURCE
+#endif
+#endif
+
+#if defined(_HPUX_SOURCE) && defined(HAVE_SYS_STREAM_H)
+#include <sys/stream.h>		/* HPUX 10.20 defines ulong here. UGLY !!! */
+#define HAVE_ULONG
+#endif
+#if defined(HPUX10) && defined(_LARGEFILE64_SOURCE)
+/* Fix bug in setrlimit */
+#undef setrlimit
+#define setrlimit cma_setrlimit64
+#endif
+/* Declare madvise where it is not declared for C++, like Solaris */
+#if HAVE_MADVISE && !HAVE_DECL_MADVISE && defined(__cplusplus)
+extern "C" int madvise(void *addr, size_t len, int behav);
+#endif
+
+#define QUOTE_ARG(x)		#x	/* Quote argument (before cpp) */
+#define STRINGIFY_ARG(x) QUOTE_ARG(x)	/* Quote argument, after cpp */
+
+/* Paranoid settings. Define I_AM_PARANOID if you are paranoid */
+#ifdef I_AM_PARANOID
+#define DONT_ALLOW_USER_CHANGE 1
+#define DONT_USE_MYSQL_PWD 1
+#endif
+
+/* Does the system remember a signal handler after a signal ? */
+#if !defined(HAVE_BSD_SIGNALS) && !defined(HAVE_SIGACTION)
+#define SIGNAL_HANDLER_RESET_ON_DELIVERY
+#endif
+
+/*
+  Deprecated workaround for false-positive uninitialized variables
+  warnings. Those should be silenced using tool-specific heuristics.
+
+  Enabled by default for g++ due to the bug referenced below.
+*/
+#if defined(_lint) || defined(FORCE_INIT_OF_VARS) || \
+    (defined(__GNUC__) && defined(__cplusplus))
+#define LINT_INIT(var) var= 0
+#else
+#define LINT_INIT(var)
+#endif
+
+#ifndef SO_EXT
+#ifdef _WIN32
+#define SO_EXT ".dll"
+#elif defined(__APPLE__)
+#define SO_EXT ".dylib"
+#else
+#define SO_EXT ".so"
+#endif
+#endif
+
+/*
+   Suppress uninitialized variable warning without generating code.
+
+   The _cplusplus is a temporary workaround for C++ code pending a fix
+   for a g++ bug (http://gcc.gnu.org/bugzilla/show_bug.cgi?id=34772).
+*/
+#if defined(_lint) || defined(FORCE_INIT_OF_VARS) || \
+    defined(__cplusplus) || !defined(__GNUC__)
+#define UNINIT_VAR(x) x= 0
+#else
+/* GCC specific self-initialization which inhibits the warning. */
+#define UNINIT_VAR(x) x= x
+#endif
+
+#if !defined(HAVE_UINT)
+#undef HAVE_UINT
+#define HAVE_UINT
+typedef unsigned int uint;
+typedef unsigned short ushort;
+#endif
+
+#define swap_variables(t, a, b) { t dummy; dummy= a; a= b; b= dummy; }
+#define test(a)		((a) ? 1 : 0)
+#define set_if_bigger(a,b)  do { if ((a) < (b)) (a)=(b); } while(0)
+#define set_if_smaller(a,b) do { if ((a) > (b)) (a)=(b); } while(0)
+#define test_all_bits(a,b) (((a) & (b)) == (b))
+#define array_elements(A) ((uint) (sizeof(A)/sizeof(A[0])))
+
+/* Define some general constants */
+#ifndef TRUE
+#define TRUE		(1)	/* Logical true */
+#define FALSE		(0)	/* Logical false */
+#endif
+
+//#include <my_compiler.h>
+
+/*
+  Wen using the embedded library, users might run into link problems,
+  duplicate declaration of __cxa_pure_virtual, solved by declaring it a
+  weak symbol.
+*/
+#if defined(USE_MYSYS_NEW) && ! defined(DONT_DECLARE_CXA_PURE_VIRTUAL)
+C_MODE_START
+int __cxa_pure_virtual () __attribute__ ((weak));
+C_MODE_END
+#endif
+
+/* The DBUG_ON flag always takes precedence over default DBUG_OFF */
+#if defined(DBUG_ON) && defined(DBUG_OFF)
+#undef DBUG_OFF
+#endif
+
+/* We might be forced to turn debug off, if not turned off already */
+#if (defined(FORCE_DBUG_OFF) || defined(_lint)) && !defined(DBUG_OFF)
+#  define DBUG_OFF
+#  ifdef DBUG_ON
+#    undef DBUG_ON
+#  endif
+#endif
+
+/* Some types that is different between systems */
+
+typedef int	File;		/* File descriptor */
+#ifdef _WIN32
+typedef SOCKET my_socket;
+#else
+typedef int	my_socket;	/* File descriptor for sockets */
+#define INVALID_SOCKET -1
+#endif
+/* Type for fuctions that handles signals */
+#define sig_handler RETSIGTYPE
+C_MODE_START
+typedef void	(*sig_return)();/* Returns type from signal */
+C_MODE_END
+#if defined(__GNUC__) && !defined(_lint)
+typedef char	pchar;		/* Mixed prototypes can take char */
+typedef char	puchar;		/* Mixed prototypes can take char */
+typedef char	pbool;		/* Mixed prototypes can take char */
+typedef short	pshort;		/* Mixed prototypes can take short int */
+typedef float	pfloat;		/* Mixed prototypes can take float */
+#else
+typedef int	pchar;		/* Mixed prototypes can't take char */
+typedef uint	puchar;		/* Mixed prototypes can't take char */
+typedef int	pbool;		/* Mixed prototypes can't take char */
+typedef int	pshort;		/* Mixed prototypes can't take short int */
+typedef double	pfloat;		/* Mixed prototypes can't take float */
+#endif
+C_MODE_START
+typedef int	(*qsort_cmp)(const void *,const void *);
+typedef int	(*qsort_cmp2)(void*, const void *,const void *);
+C_MODE_END
+#define qsort_t RETQSORTTYPE	/* Broken GCC cant handle typedef !!!! */
+#ifdef HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+typedef SOCKET_SIZE_TYPE size_socket;
+
+#ifndef SOCKOPT_OPTLEN_TYPE
+#define SOCKOPT_OPTLEN_TYPE size_socket
+#endif
+
+/* file create flags */
+
+#ifndef O_SHARE			/* Probably not windows */
+#define O_SHARE		0	/* Flag to my_open for shared files */
+#ifndef O_BINARY
+#define O_BINARY	0	/* Flag to my_open for binary files */
+#endif
+#ifndef FILE_BINARY
+#define FILE_BINARY	O_BINARY /* Flag to my_fopen for binary streams */
+#endif
+#ifdef HAVE_FCNTL
+#define HAVE_FCNTL_LOCK
+#define F_TO_EOF	0L	/* Param to lockf() to lock rest of file */
+#endif
+#endif /* O_SHARE */
+
+#ifndef O_TEMPORARY
+#define O_TEMPORARY	0
+#endif
+#ifndef O_SHORT_LIVED
+#define O_SHORT_LIVED	0
+#endif
+#ifndef O_NOFOLLOW
+#define O_NOFOLLOW      0
+#endif
+
+/* additional file share flags for win32 */
+#ifdef __WIN__
+#define _SH_DENYRWD     0x110    /* deny read/write mode & delete */
+#define _SH_DENYWRD     0x120    /* deny write mode & delete      */
+#define _SH_DENYRDD     0x130    /* deny read mode & delete       */
+#define _SH_DENYDEL     0x140    /* deny delete only              */
+#endif /* __WIN__ */
+
+
+/* General constants */
+#define FN_LEN		256	/* Max file name len */
+#define FN_HEADLEN	253	/* Max length of filepart of file name */
+#define FN_EXTLEN	20	/* Max length of extension (part of FN_LEN) */
+#define FN_REFLEN	512	/* Max length of full path-name */
+#define FN_EXTCHAR	'.'
+#define FN_HOMELIB	'~'	/* ~/ is used as abbrev for home dir */
+#define FN_CURLIB	'.'	/* ./ is used as abbrev for current dir */
+#define FN_PARENTDIR	".."	/* Parent directory; Must be a string */
+
+#ifdef _WIN32
+#define FN_LIBCHAR	'\\'
+#define FN_LIBCHAR2	'/'
+#define FN_DIRSEP       "/\\"               /* Valid directory separators */
+#define FN_ROOTDIR	"\\"
+#define FN_DEVCHAR	':'
+#define FN_NETWORK_DRIVES	/* Uses \\ to indicate network drives */
+#define FN_NO_CASE_SENCE	/* Files are not case-sensitive */
+#else
+#define FN_LIBCHAR	'/'
+#define FN_LIBCHAR2	'/'
+#define FN_DIRSEP       "/"     /* Valid directory separators */
+#define FN_ROOTDIR	"/"
+#endif
+
+/* 
+  MY_FILE_MIN is  Windows speciality and is used to quickly detect
+  the mismatch of CRT and mysys file IO usage on Windows at runtime.
+  CRT file descriptors can be in the range 0-2047, whereas descriptors returned
+  by my_open() will start with 2048. If a file descriptor with value less then
+  MY_FILE_MIN is passed to mysys IO function, chances are it stemms from
+  open()/fileno() and not my_open()/my_fileno.
+
+  For Posix,  mysys functions are light wrappers around libc, and MY_FILE_MIN
+  is logically 0.
+*/
+
+#ifdef _WIN32
+#define MY_FILE_MIN  2048
+#else
+#define MY_FILE_MIN  0
+#endif
+
+/* 
+  MY_NFILE is the default size of my_file_info array.
+
+  It is larger on Windows, because it all file handles are stored in my_file_info
+  Default size is 16384 and this should be enough for most cases.If it is not 
+  enough, --max-open-files with larger value can be used.
+
+  For Posix , my_file_info array is only used to store filenames for
+  error reporting and its size is not a limitation for number of open files.
+*/ 
+#ifdef _WIN32
+#define MY_NFILE (16384 + MY_FILE_MIN)
+#else
+#define MY_NFILE 64
+#endif
+
+#ifndef OS_FILE_LIMIT
+#define OS_FILE_LIMIT	UINT_MAX
+#endif
+
+/*
+  Io buffer size; Must be a power of 2 and a multiple of 512. May be
+  smaller what the disk page size. This influences the speed of the
+  isam btree library. eg to big to slow.
+*/
+#define IO_SIZE			4096
+/*
+  How much overhead does malloc have. The code often allocates
+  something like 1024-MALLOC_OVERHEAD bytes
+*/
+#define MALLOC_OVERHEAD 8
+
+	/* get memory in huncs */
+#define ONCE_ALLOC_INIT		(uint) (4096-MALLOC_OVERHEAD)
+	/* Typical record cash */
+#define RECORD_CACHE_SIZE	(uint) (64*1024-MALLOC_OVERHEAD)
+	/* Typical key cash */
+#define KEY_CACHE_SIZE		(uint) (8*1024*1024)
+	/* Default size of a key cache block  */
+#define KEY_CACHE_BLOCK_SIZE	(uint) 1024
+
+
+	/* Some things that this system doesn't have */
+
+#ifdef _WIN32
+#define NO_DIR_LIBRARY		/* Not standard dir-library */
+#endif
+
+/* Some defines of functions for portability */
+
+#undef remove		/* Crashes MySQL on SCO 5.0.0 */
+#ifndef __WIN__
+#define closesocket(A)	close(A)
+#endif
+
+#if (_MSC_VER)
+#if !defined(_WIN64)
+inline double my_ulonglong2double(unsigned long long value)
+{
+  long long nr=(long long) value;
+  if (nr >= 0)
+    return (double) nr;
+  return (18446744073709551616.0 + (double) nr);
+}
+#define ulonglong2double my_ulonglong2double
+#define my_off_t2double  my_ulonglong2double
+#endif /* _WIN64 */
+inline unsigned long long my_double2ulonglong(double d)
+{
+  double t= d - (double) 0x8000000000000000ULL;
+
+  if (t >= 0)
+    return  ((unsigned long long) t) + 0x8000000000000000ULL;
+  return (unsigned long long) d;
+}
+#define double2ulonglong my_double2ulonglong
+#endif
+
+#ifndef ulonglong2double
+#define ulonglong2double(A) ((double) (ulonglong) (A))
+#define my_off_t2double(A)  ((double) (my_off_t) (A))
+#endif
+#ifndef double2ulonglong
+#define double2ulonglong(A) ((ulonglong) (double) (A))
+#endif
+
+#ifndef offsetof
+#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
+#endif
+#define ulong_to_double(X) ((double) (ulong) (X))
+
+#ifndef STACK_DIRECTION
+#error "please add -DSTACK_DIRECTION=1 or -1 to your CPPFLAGS"
+#endif
+
+#if !defined(HAVE_STRTOK_R)
+#define strtok_r(A,B,C) strtok((A),(B))
+#endif
+
+/* This is from the old m-machine.h file */
+
+#if SIZEOF_LONG_LONG > 4
+#define HAVE_LONG_LONG 1
+#endif
+
+/*
+  Some pre-ANSI-C99 systems like AIX 5.1 and Linux/GCC 2.95 define
+  ULONGLONG_MAX, LONGLONG_MIN, LONGLONG_MAX; we use them if they're defined.
+*/
+
+#if defined(HAVE_LONG_LONG) && !defined(LONGLONG_MIN)
+#define LONGLONG_MIN	((long long) 0x8000000000000000LL)
+#define LONGLONG_MAX	((long long) 0x7FFFFFFFFFFFFFFFLL)
+#endif
+
+#if defined(HAVE_LONG_LONG) && !defined(ULONGLONG_MAX)
+/* First check for ANSI C99 definition: */
+#ifdef ULLONG_MAX
+#define ULONGLONG_MAX  ULLONG_MAX
+#else
+#define ULONGLONG_MAX ((unsigned long long)(~0ULL))
+#endif
+#endif /* defined (HAVE_LONG_LONG) && !defined(ULONGLONG_MAX)*/
+
+#define INT_MIN64       (~0x7FFFFFFFFFFFFFFFLL)
+#define INT_MAX64       0x7FFFFFFFFFFFFFFFLL
+#define INT_MIN32       (~0x7FFFFFFFL)
+#define INT_MAX32       0x7FFFFFFFL
+#define UINT_MAX32      0xFFFFFFFFL
+#define INT_MIN24       (~0x007FFFFF)
+#define INT_MAX24       0x007FFFFF
+#define UINT_MAX24      0x00FFFFFF
+#define INT_MIN16       (~0x7FFF)
+#define INT_MAX16       0x7FFF
+#define UINT_MAX16      0xFFFF
+#define INT_MIN8        (~0x7F)
+#define INT_MAX8        0x7F
+#define UINT_MAX8       0xFF
+
+/* From limits.h instead */
+#ifndef DBL_MIN
+#define DBL_MIN		4.94065645841246544e-324
+#define FLT_MIN		((float)1.40129846432481707e-45)
+#endif
+#ifndef DBL_MAX
+#define DBL_MAX		1.79769313486231470e+308
+#define FLT_MAX		((float)3.40282346638528860e+38)
+#endif
+#ifndef SIZE_T_MAX
+#define SIZE_T_MAX      (~((size_t) 0))
+#endif
+
+#ifndef isfinite
+#ifdef HAVE_FINITE
+#define isfinite(x) finite(x)
+#else
+#define finite(x) (1.0 / fabs(x) > 0.0)
+#endif /* HAVE_FINITE */
+#endif /* isfinite */
+
+#ifndef HAVE_ISNAN
+#define isnan(x) ((x) != (x))
+#endif
+
+#ifdef HAVE_ISINF
+/* Check if C compiler is affected by GCC bug #39228 */
+#if !defined(__cplusplus) && defined(HAVE_BROKEN_ISINF)
+/* Force store/reload of the argument to/from a 64-bit double */
+static inline double my_isinf(double x)
+{
+  volatile double t= x;
+  return isinf(t);
+}
+#else
+/* System-provided isinf() is available and safe to use */
+#define my_isinf(X) isinf(X)
+#endif
+#else /* !HAVE_ISINF */
+#define my_isinf(X) (!finite(X) && !isnan(X))
+#endif
+
+/* Define missing math constants. */
+#ifndef M_PI
+#define M_PI 3.14159265358979323846
+#endif
+#ifndef M_E
+#define M_E 2.7182818284590452354
+#endif
+#ifndef M_LN2
+#define M_LN2 0.69314718055994530942
+#endif
+
+/*
+  Max size that must be added to a so that we know Size to make
+  adressable obj.
+*/
+#if SIZEOF_CHARP == 4
+typedef long		my_ptrdiff_t;
+#else
+typedef long long	my_ptrdiff_t;
+#endif
+
+#define MY_ALIGN(A,L)	(((A) + (L) - 1) & ~((L) - 1))
+#define ALIGN_SIZE(A)	MY_ALIGN((A),sizeof(double))
+/* Size to make adressable obj. */
+#define ADD_TO_PTR(ptr,size,type) (type) ((uchar*) (ptr)+size)
+#define PTR_BYTE_DIFF(A,B) (my_ptrdiff_t) ((uchar*) (A) - (uchar*) (B))
+
+/*
+  Custom version of standard offsetof() macro which can be used to get
+  offsets of members in class for non-POD types (according to the current
+  version of C++ standard offsetof() macro can't be used in such cases and
+  attempt to do so causes warnings to be emitted, OTOH in many cases it is
+  still OK to assume that all instances of the class has the same offsets
+  for the same members).
+
+  This is temporary solution which should be removed once File_parser class
+  and related routines are refactored.
+*/
+
+#define my_offsetof(TYPE, MEMBER) \
+        ((size_t)((char *)&(((TYPE *)0x10)->MEMBER) - (char*)0x10))
+
+#define NullS		(char *) 0
+
+#ifdef STDCALL
+#undef STDCALL
+#endif
+
+#ifdef _WIN32
+#define STDCALL __stdcall
+#else
+#define STDCALL
+#endif
+
+/* Typdefs for easyier portability */
+
+#ifndef HAVE_UCHAR
+typedef unsigned char	uchar;	/* Short for unsigned char */
+#endif
+
+#ifndef HAVE_INT8
+typedef signed char int8;       /* Signed integer >= 8  bits */
+#endif
+#ifndef HAVE_UINT8
+typedef unsigned char uint8;    /* Unsigned integer >= 8  bits */
+#endif
+#ifndef HAVE_INT16
+typedef short int16;
+#endif
+#ifndef HAVE_UINT16
+typedef unsigned short uint16;
+#endif
+#if SIZEOF_INT == 4
+#ifndef HAVE_INT32
+typedef int int32;
+#endif
+#ifndef HAVE_UINT32
+typedef unsigned int uint32;
+#endif
+#elif SIZEOF_LONG == 4
+#ifndef HAVE_INT32
+typedef long int32;
+#endif
+#ifndef HAVE_UINT32
+typedef unsigned long uint32;
+#endif
+#else
+#error Neither int or long is of 4 bytes width
+#endif
+
+#if !defined(HAVE_ULONG) && !defined(__USE_MISC)
+typedef unsigned long	ulong;		  /* Short for unsigned long */
+#endif
+#ifndef longlong_defined
+/* 
+  Using [unsigned] long long is preferable as [u]longlong because we use 
+  [unsigned] long long unconditionally in many places, 
+  for example in constants with [U]LL suffix.
+*/
+#if defined(HAVE_LONG_LONG) && SIZEOF_LONG_LONG == 8
+typedef unsigned long long int ulonglong; /* ulong or unsigned long long */
+typedef long long int	longlong;
+#else
+typedef unsigned long	ulonglong;	  /* ulong or unsigned long long */
+typedef long		longlong;
+#endif
+#endif
+#ifndef HAVE_INT64
+typedef longlong int64;
+#endif
+#ifndef HAVE_UINT64
+typedef ulonglong uint64;
+#endif
+
+#if defined(NO_CLIENT_LONG_LONG)
+typedef unsigned long my_ulonglong;
+#elif defined (__WIN__)
+typedef unsigned __int64 my_ulonglong;
+#else
+typedef unsigned long long my_ulonglong;
+#endif
+
+#if SIZEOF_CHARP == SIZEOF_INT
+typedef int intptr;
+#elif SIZEOF_CHARP == SIZEOF_LONG
+typedef long intptr;
+#elif SIZEOF_CHARP == SIZEOF_LONG_LONG
+typedef long long intptr;
+#else
+#error sizeof(void *) is neither sizeof(int) nor sizeof(long) nor sizeof(long long)
+#endif
+
+#define MY_ERRPTR ((void*)(intptr)1)
+
+#if defined(_WIN32)
+typedef unsigned long long my_off_t;
+typedef unsigned long long os_off_t;
+#else
+typedef off_t os_off_t;
+#if SIZEOF_OFF_T > 4
+typedef ulonglong my_off_t;
+#else
+typedef unsigned long my_off_t;
+#endif
+#endif /*_WIN32*/
+#define MY_FILEPOS_ERROR	(~(my_off_t) 0)
+
+/*
+  TODO Convert these to use Bitmap class.
+ */
+typedef ulonglong table_map;          /* Used for table bits in join */
+typedef ulong nesting_map;  /* Used for flags of nesting constructs */
+
+#if defined(__WIN__)
+#define socket_errno	WSAGetLastError()
+#define SOCKET_EINTR	WSAEINTR
+#define SOCKET_EAGAIN	WSAEINPROGRESS
+#define SOCKET_ETIMEDOUT WSAETIMEDOUT
+#define SOCKET_EWOULDBLOCK WSAEWOULDBLOCK
+#define SOCKET_EADDRINUSE WSAEADDRINUSE
+#define SOCKET_ENFILE	ENFILE
+#define SOCKET_EMFILE	EMFILE
+#else /* Unix */
+#define socket_errno	errno
+#define closesocket(A)	close(A)
+#define SOCKET_EINTR	EINTR
+#define SOCKET_EAGAIN	EAGAIN
+#define SOCKET_ETIMEDOUT SOCKET_EINTR
+#define SOCKET_EWOULDBLOCK EWOULDBLOCK
+#define SOCKET_EADDRINUSE EADDRINUSE
+#define SOCKET_ENFILE	ENFILE
+#define SOCKET_EMFILE	EMFILE
+#endif
+
+typedef int		myf;	/* Type of MyFlags in my_funcs */
+typedef char		my_bool; /* Small bool */
+
+/* Macros for converting *constants* to the right type */
+#define MYF(v)		(myf) (v)
+
+#ifndef LL
+#ifdef HAVE_LONG_LONG
+#define LL(A) A ## LL
+#else
+#define LL(A) A ## L
+#endif
+#endif
+
+#ifndef ULL
+#ifdef HAVE_LONG_LONG
+#define ULL(A) A ## ULL
+#else
+#define ULL(A) A ## UL
+#endif
+#endif
+
+/*
+  Defines to make it possible to prioritize register assignments. No
+  longer that important with modern compilers.
+*/
+#ifndef USING_X
+#define reg1 register
+#define reg2 register
+#define reg3 register
+#define reg4 register
+#define reg5 register
+#define reg6 register
+#define reg7 register
+#define reg8 register
+#define reg9 register
+#define reg10 register
+#define reg11 register
+#define reg12 register
+#define reg13 register
+#define reg14 register
+#define reg15 register
+#define reg16 register
+#endif
+
+#include <my_dbug.h>
+
+/* Some helper macros */
+#define YESNO(X) ((X) ? "yes" : "no")
+
+#define MY_HOW_OFTEN_TO_ALARM	2	/* How often we want info on screen */
+#define MY_HOW_OFTEN_TO_WRITE	1000	/* How often we want info on screen */
+
+
+
+/*
+  Define-funktions for reading and storing in machine independent format
+  (low byte first)
+*/
+
+/* Optimized store functions for Intel x86 */
+#if defined(__i386__) || defined(_WIN32)
+#define sint2korr(A)	(*((int16 *) (A)))
+#define sint3korr(A)	((int32) ((((uchar) (A)[2]) & 128) ? \
+				  (((uint32) 255L << 24) | \
+				   (((uint32) (uchar) (A)[2]) << 16) |\
+				   (((uint32) (uchar) (A)[1]) << 8) | \
+				   ((uint32) (uchar) (A)[0])) : \
+				  (((uint32) (uchar) (A)[2]) << 16) |\
+				  (((uint32) (uchar) (A)[1]) << 8) | \
+				  ((uint32) (uchar) (A)[0])))
+#define sint4korr(A)	(*((long *) (A)))
+#define uint2korr(A)	(*((uint16 *) (A)))
+#if defined(HAVE_purify) && !defined(_WIN32)
+#define uint3korr(A)	(uint32) (((uint32) ((uchar) (A)[0])) +\
+				  (((uint32) ((uchar) (A)[1])) << 8) +\
+				  (((uint32) ((uchar) (A)[2])) << 16))
+#else
+/*
+   ATTENTION !
+   
+    Please, note, uint3korr reads 4 bytes (not 3) !
+    It means, that you have to provide enough allocated space !
+*/
+#define uint3korr(A)	(long) (*((unsigned int *) (A)) & 0xFFFFFF)
+#endif /* HAVE_purify && !_WIN32 */
+#define uint4korr(A)	(*((uint32 *) (A)))
+#define uint5korr(A)	((ulonglong)(((uint32) ((uchar) (A)[0])) +\
+				    (((uint32) ((uchar) (A)[1])) << 8) +\
+				    (((uint32) ((uchar) (A)[2])) << 16) +\
+				    (((uint32) ((uchar) (A)[3])) << 24)) +\
+				    (((ulonglong) ((uchar) (A)[4])) << 32))
+#define uint6korr(A)	((ulonglong)(((uint32)    ((uchar) (A)[0]))          + \
+                                     (((uint32)    ((uchar) (A)[1])) << 8)   + \
+                                     (((uint32)    ((uchar) (A)[2])) << 16)  + \
+                                     (((uint32)    ((uchar) (A)[3])) << 24)) + \
+                         (((ulonglong) ((uchar) (A)[4])) << 32) +       \
+                         (((ulonglong) ((uchar) (A)[5])) << 40))
+#define uint8korr(A)	(*((ulonglong *) (A)))
+#define sint8korr(A)	(*((longlong *) (A)))
+#define int2store(T,A)	*((uint16*) (T))= (uint16) (A)
+#define int3store(T,A)  do { *(T)=  (uchar) ((A));\
+                            *(T+1)=(uchar) (((uint) (A) >> 8));\
+                            *(T+2)=(uchar) (((A) >> 16)); } while (0)
+#define int4store(T,A)	*((long *) (T))= (long) (A)
+#define int5store(T,A)  do { *(T)= (uchar)((A));\
+                             *((T)+1)=(uchar) (((A) >> 8));\
+                             *((T)+2)=(uchar) (((A) >> 16));\
+                             *((T)+3)=(uchar) (((A) >> 24)); \
+                             *((T)+4)=(uchar) (((A) >> 32)); } while(0)
+#define int6store(T,A)  do { *(T)=    (uchar)((A));          \
+                             *((T)+1)=(uchar) (((A) >> 8));  \
+                             *((T)+2)=(uchar) (((A) >> 16)); \
+                             *((T)+3)=(uchar) (((A) >> 24)); \
+                             *((T)+4)=(uchar) (((A) >> 32)); \
+                             *((T)+5)=(uchar) (((A) >> 40)); } while(0)
+#define int8store(T,A)	*((ulonglong *) (T))= (ulonglong) (A)
+/*
+typedef union {
+  double v;
+  long m[2];
+} doubleget_union;
+*/
+#define doubleget(V,M)	\
+do { doubleget_union _tmp; \
+     _tmp.m[0] = *((long*)(M)); \
+     _tmp.m[1] = *(((long*) (M))+1); \
+     (V) = _tmp.v; } while(0)
+#define doublestore(T,V) do { *((long *) T) = ((doubleget_union *)&V)->m[0]; \
+			     *(((long *) T)+1) = ((doubleget_union *)&V)->m[1]; \
+                         } while (0)
+#define float4get(V,M)   do { *((float *) &(V)) = *((float*) (M)); } while(0)
+#define float8get(V,M)   doubleget((V),(M))
+#define float4store(V,M) memcpy((uchar*) V,(uchar*) (&M),sizeof(float))
+#define floatstore(T,V)  memcpy((uchar*)(T), (uchar*)(&V),sizeof(float))
+#define floatget(V,M)    memcpy((uchar*) &V,(uchar*) (M),sizeof(float))
+#define float8store(V,M) doublestore((V),(M))
+#else
+
+/*
+  We're here if it's not a IA-32 architecture (Win32 and UNIX IA-32 defines
+  were done before)
+*/
+#define sint2korr(A)	(int16) (((int16) ((uchar) (A)[0])) +\
+				 ((int16) ((int16) (A)[1]) << 8))
+#define sint3korr(A)	((int32) ((((uchar) (A)[2]) & 128) ? \
+				  (((uint32) 255L << 24) | \
+				   (((uint32) (uchar) (A)[2]) << 16) |\
+				   (((uint32) (uchar) (A)[1]) << 8) | \
+				   ((uint32) (uchar) (A)[0])) : \
+				  (((uint32) (uchar) (A)[2]) << 16) |\
+				  (((uint32) (uchar) (A)[1]) << 8) | \
+				  ((uint32) (uchar) (A)[0])))
+#define sint4korr(A)	(int32) (((int32) ((uchar) (A)[0])) +\
+				(((int32) ((uchar) (A)[1]) << 8)) +\
+				(((int32) ((uchar) (A)[2]) << 16)) +\
+				(((int32) ((int16) (A)[3]) << 24)))
+#define sint8korr(A)	(longlong) uint8korr(A)
+#define uint2korr(A)	(uint16) (((uint16) ((uchar) (A)[0])) +\
+				  ((uint16) ((uchar) (A)[1]) << 8))
+#define uint3korr(A)	(uint32) (((uint32) ((uchar) (A)[0])) +\
+				  (((uint32) ((uchar) (A)[1])) << 8) +\
+				  (((uint32) ((uchar) (A)[2])) << 16))
+#define uint4korr(A)	(uint32) (((uint32) ((uchar) (A)[0])) +\
+				  (((uint32) ((uchar) (A)[1])) << 8) +\
+				  (((uint32) ((uchar) (A)[2])) << 16) +\
+				  (((uint32) ((uchar) (A)[3])) << 24))
+#define uint5korr(A)	((ulonglong)(((uint32) ((uchar) (A)[0])) +\
+				    (((uint32) ((uchar) (A)[1])) << 8) +\
+				    (((uint32) ((uchar) (A)[2])) << 16) +\
+				    (((uint32) ((uchar) (A)[3])) << 24)) +\
+				    (((ulonglong) ((uchar) (A)[4])) << 32))
+#define uint6korr(A)	((ulonglong)(((uint32)    ((uchar) (A)[0]))          + \
+                                     (((uint32)    ((uchar) (A)[1])) << 8)   + \
+                                     (((uint32)    ((uchar) (A)[2])) << 16)  + \
+                                     (((uint32)    ((uchar) (A)[3])) << 24)) + \
+                         (((ulonglong) ((uchar) (A)[4])) << 32) +       \
+                         (((ulonglong) ((uchar) (A)[5])) << 40))
+#define uint8korr(A)	((ulonglong)(((uint32) ((uchar) (A)[0])) +\
+				    (((uint32) ((uchar) (A)[1])) << 8) +\
+				    (((uint32) ((uchar) (A)[2])) << 16) +\
+				    (((uint32) ((uchar) (A)[3])) << 24)) +\
+			(((ulonglong) (((uint32) ((uchar) (A)[4])) +\
+				    (((uint32) ((uchar) (A)[5])) << 8) +\
+				    (((uint32) ((uchar) (A)[6])) << 16) +\
+				    (((uint32) ((uchar) (A)[7])) << 24))) <<\
+				    32))
+#define int2store(T,A)       do { uint def_temp= (uint) (A) ;\
+                                  *((uchar*) (T))=  (uchar)(def_temp); \
+                                   *((uchar*) (T)+1)=(uchar)((def_temp >> 8)); \
+                             } while(0)
+#define int3store(T,A)       do { /*lint -save -e734 */\
+                                  *((uchar*)(T))=(uchar) ((A));\
+                                  *((uchar*) (T)+1)=(uchar) (((A) >> 8));\
+                                  *((uchar*)(T)+2)=(uchar) (((A) >> 16)); \
+                                  /*lint -restore */} while(0)
+#define int4store(T,A)       do { *((char *)(T))=(char) ((A));\
+                                  *(((char *)(T))+1)=(char) (((A) >> 8));\
+                                  *(((char *)(T))+2)=(char) (((A) >> 16));\
+                                  *(((char *)(T))+3)=(char) (((A) >> 24)); } while(0)
+#define int5store(T,A)       do { *((char *)(T))=     (char)((A));  \
+                                  *(((char *)(T))+1)= (char)(((A) >> 8)); \
+                                  *(((char *)(T))+2)= (char)(((A) >> 16)); \
+                                  *(((char *)(T))+3)= (char)(((A) >> 24)); \
+                                  *(((char *)(T))+4)= (char)(((A) >> 32)); \
+		                } while(0)
+#define int6store(T,A)       do { *((char *)(T))=     (char)((A)); \
+                                  *(((char *)(T))+1)= (char)(((A) >> 8)); \
+                                  *(((char *)(T))+2)= (char)(((A) >> 16)); \
+                                  *(((char *)(T))+3)= (char)(((A) >> 24)); \
+                                  *(((char *)(T))+4)= (char)(((A) >> 32)); \
+                                  *(((char *)(T))+5)= (char)(((A) >> 40)); \
+                                } while(0)
+#define int8store(T,A)       do { uint def_temp= (uint) (A), def_temp2= (uint) ((A) >> 32); \
+                                  int4store((T),def_temp); \
+                                  int4store((T+4),def_temp2); } while(0)
+#ifdef WORDS_BIGENDIAN
+#define float4store(T,A) do { *(T)= ((uchar *) &A)[3];\
+                              *((T)+1)=(char) ((uchar *) &A)[2];\
+                              *((T)+2)=(char) ((uchar *) &A)[1];\
+                              *((T)+3)=(char) ((uchar *) &A)[0]; } while(0)
+
+#define float4get(V,M)   do { float def_temp;\
+                              ((uchar*) &def_temp)[0]=(M)[3];\
+                              ((uchar*) &def_temp)[1]=(M)[2];\
+                              ((uchar*) &def_temp)[2]=(M)[1];\
+                              ((uchar*) &def_temp)[3]=(M)[0];\
+                              (V)=def_temp; } while(0)
+#define float8store(T,V) do { *(T)= ((uchar *) &V)[7];\
+                              *((T)+1)=(char) ((uchar *) &V)[6];\
+                              *((T)+2)=(char) ((uchar *) &V)[5];\
+                              *((T)+3)=(char) ((uchar *) &V)[4];\
+                              *((T)+4)=(char) ((uchar *) &V)[3];\
+                              *((T)+5)=(char) ((uchar *) &V)[2];\
+                              *((T)+6)=(char) ((uchar *) &V)[1];\
+                              *((T)+7)=(char) ((uchar *) &V)[0]; } while(0)
+
+#define float8get(V,M)   do { double def_temp;\
+                              ((uchar*) &def_temp)[0]=(M)[7];\
+                              ((uchar*) &def_temp)[1]=(M)[6];\
+                              ((uchar*) &def_temp)[2]=(M)[5];\
+                              ((uchar*) &def_temp)[3]=(M)[4];\
+                              ((uchar*) &def_temp)[4]=(M)[3];\
+                              ((uchar*) &def_temp)[5]=(M)[2];\
+                              ((uchar*) &def_temp)[6]=(M)[1];\
+                              ((uchar*) &def_temp)[7]=(M)[0];\
+                              (V) = def_temp; } while(0)
+#else
+#define float4get(V,M)   memcpy(&V, (M), sizeof(float))
+#define float4store(V,M) memcpy(V, (&M), sizeof(float))
+
+#if defined(__FLOAT_WORD_ORDER) && (__FLOAT_WORD_ORDER == __BIG_ENDIAN)
+#define doublestore(T,V) do { *(((char*)T)+0)=(char) ((uchar *) &V)[4];\
+                              *(((char*)T)+1)=(char) ((uchar *) &V)[5];\
+                              *(((char*)T)+2)=(char) ((uchar *) &V)[6];\
+                              *(((char*)T)+3)=(char) ((uchar *) &V)[7];\
+                              *(((char*)T)+4)=(char) ((uchar *) &V)[0];\
+                              *(((char*)T)+5)=(char) ((uchar *) &V)[1];\
+                              *(((char*)T)+6)=(char) ((uchar *) &V)[2];\
+                              *(((char*)T)+7)=(char) ((uchar *) &V)[3]; }\
+                         while(0)
+#define doubleget(V,M)   do { double def_temp;\
+                              ((uchar*) &def_temp)[0]=(M)[4];\
+                              ((uchar*) &def_temp)[1]=(M)[5];\
+                              ((uchar*) &def_temp)[2]=(M)[6];\
+                              ((uchar*) &def_temp)[3]=(M)[7];\
+                              ((uchar*) &def_temp)[4]=(M)[0];\
+                              ((uchar*) &def_temp)[5]=(M)[1];\
+                              ((uchar*) &def_temp)[6]=(M)[2];\
+                              ((uchar*) &def_temp)[7]=(M)[3];\
+                              (V) = def_temp; } while(0)
+#endif /* __FLOAT_WORD_ORDER */
+
+#define float8get(V,M)   doubleget((V),(M))
+#define float8store(V,M) doublestore((V),(M))
+#endif /* WORDS_BIGENDIAN */
+
+#endif /* __i386__ OR _WIN32 */
+
+/*
+  Macro for reading 32-bit integer from network byte order (big-endian)
+  from unaligned memory location.
+*/
+#define int4net(A)        (int32) (((uint32) ((uchar) (A)[3]))        |\
+				  (((uint32) ((uchar) (A)[2])) << 8)  |\
+				  (((uint32) ((uchar) (A)[1])) << 16) |\
+				  (((uint32) ((uchar) (A)[0])) << 24))
+/*
+  Define-funktions for reading and storing in machine format from/to
+  short/long to/from some place in memory V should be a (not
+  register) variable, M is a pointer to byte
+*/
+
+#ifdef WORDS_BIGENDIAN
+
+#define ushortget(V,M)  do { V = (uint16) (((uint16) ((uchar) (M)[1]))+\
+                                 ((uint16) ((uint16) (M)[0]) << 8)); } while(0)
+#define shortget(V,M)   do { V = (short) (((short) ((uchar) (M)[1]))+\
+                                 ((short) ((short) (M)[0]) << 8)); } while(0)
+#define longget(V,M)    do { int32 def_temp;\
+                             ((uchar*) &def_temp)[0]=(M)[0];\
+                             ((uchar*) &def_temp)[1]=(M)[1];\
+                             ((uchar*) &def_temp)[2]=(M)[2];\
+                             ((uchar*) &def_temp)[3]=(M)[3];\
+                             (V)=def_temp; } while(0)
+#define ulongget(V,M)   do { uint32 def_temp;\
+                            ((uchar*) &def_temp)[0]=(M)[0];\
+                            ((uchar*) &def_temp)[1]=(M)[1];\
+                            ((uchar*) &def_temp)[2]=(M)[2];\
+                            ((uchar*) &def_temp)[3]=(M)[3];\
+                            (V)=def_temp; } while(0)
+#define shortstore(T,A) do { uint def_temp=(uint) (A) ;\
+                             *(((char*)T)+1)=(char)(def_temp); \
+                             *(((char*)T)+0)=(char)(def_temp >> 8); } while(0)
+#define longstore(T,A)  do { *(((char*)T)+3)=((A));\
+                             *(((char*)T)+2)=(((A) >> 8));\
+                             *(((char*)T)+1)=(((A) >> 16));\
+                             *(((char*)T)+0)=(((A) >> 24)); } while(0)
+
+#define floatget(V,M)    memcpy(&V, (M), sizeof(float))
+#define floatstore(T,V)  memcpy((T), (void*) (&V), sizeof(float))
+#define doubleget(V,M)	 memcpy(&V, (M), sizeof(double))
+#define doublestore(T,V) memcpy((T), (void *) &V, sizeof(double))
+#define longlongget(V,M) memcpy(&V, (M), sizeof(ulonglong))
+#define longlongstore(T,V) memcpy((T), &V, sizeof(ulonglong))
+
+#else
+
+#define ushortget(V,M)	do { V = uint2korr(M); } while(0)
+#define shortget(V,M)	do { V = sint2korr(M); } while(0)
+#define longget(V,M)	do { V = sint4korr(M); } while(0)
+#define ulongget(V,M)   do { V = uint4korr(M); } while(0)
+#define shortstore(T,V) int2store(T,V)
+#define longstore(T,V)	int4store(T,V)
+#ifndef floatstore
+#define floatstore(T,V)  memcpy((T), (void *) (&V), sizeof(float))
+#define floatget(V,M)    memcpy(&V, (M), sizeof(float))
+#endif
+#ifndef doubleget
+#define doubleget(V,M)	 memcpy(&V, (M), sizeof(double))
+#define doublestore(T,V) memcpy((T), (void *) &V, sizeof(double))
+#endif /* doubleget */
+#define longlongget(V,M) memcpy(&V, (M), sizeof(ulonglong))
+#define longlongstore(T,V) memcpy((T), &V, sizeof(ulonglong))
+
+#endif /* WORDS_BIGENDIAN */
+
+#ifdef HAVE_CHARSET_utf8
+#define MYSQL_UNIVERSAL_CLIENT_CHARSET "utf8"
+#else
+#define MYSQL_UNIVERSAL_CLIENT_CHARSET MYSQL_DEFAULT_CHARSET_NAME
+#endif
+
+#if defined(EMBEDDED_LIBRARY) && !defined(HAVE_EMBEDDED_PRIVILEGE_CONTROL)
+#define NO_EMBEDDED_ACCESS_CHECKS
+#endif
+
+#if defined(_WIN32)
+#define dlsym(lib, name) (void*)GetProcAddress((HMODULE)lib, name)
+#define dlopen(libname, unused) LoadLibraryEx(libname, NULL, 0)
+#define dlclose(lib) FreeLibrary((HMODULE)lib)
+#ifndef HAVE_DLOPEN
+#define HAVE_DLOPEN
+#endif
+#endif
+
+#ifdef HAVE_DLOPEN
+#if defined(HAVE_DLFCN_H)
+#include <dlfcn.h>
+#endif
+#endif
+
+#ifndef HAVE_DLERROR
+#ifdef _WIN32
+#define dlerror() ""
+#else
+#define dlerror() "No support for dynamic loading (static build?)"
+#endif
+#endif
+
+
+/*
+ *  Include standard definitions of operator new and delete.
+ */
+#ifdef __cplusplus
+#include <new>
+#endif
+
+/* Length of decimal number represented by INT32. */
+#define MY_INT32_NUM_DECIMAL_DIGITS 11
+
+/* Length of decimal number represented by INT64. */
+#define MY_INT64_NUM_DECIMAL_DIGITS 21
+
+/* Define some useful general macros (should be done after all headers). */
+#if !defined(max)
+#define max(a, b)	((a) > (b) ? (a) : (b))
+#define min(a, b)	((a) < (b) ? (a) : (b))
+#endif  
+
+/*
+  Only Linux is known to need an explicit sync of the directory to make sure a
+  file creation/deletion/renaming in(from,to) this directory durable.
+*/
+#ifdef TARGET_OS_LINUX
+#define NEED_EXPLICIT_SYNC_DIR 1
+#endif
+
+#if !defined(__cplusplus) && !defined(bool)
+#define bool In_C_you_should_use_my_bool_instead()
+#endif
+
+/* Provide __func__ macro definition for platforms that miss it. */
+#if __STDC_VERSION__ < 199901L
+#  if __GNUC__ >= 2
+#    define __func__ __FUNCTION__
+#  else
+#    define __func__ "<unknown>"
+#  endif
+#elif defined(_MSC_VER)
+#  if _MSC_VER < 1300
+#    define __func__ "<unknown>"
+#  else
+#    define __func__ __FUNCTION__
+#  endif
+#elif defined(__BORLANDC__)
+#  define __func__ __FUNC__
+#else
+#  define __func__ "<unknown>"
+#endif
+
+#ifndef HAVE_RINT
+/**
+   All integers up to this number can be represented exactly as double precision
+   values (DBL_MANT_DIG == 53 for IEEE 754 hardware).
+*/
+#define MAX_EXACT_INTEGER ((1LL << DBL_MANT_DIG) - 1)
+
+/**
+   rint(3) implementation for platforms that do not have it.
+   Always rounds to the nearest integer with ties being rounded to the nearest
+   even integer to mimic glibc's rint() behavior in the "round-to-nearest"
+   FPU mode. Hardware-specific optimizations are possible (frndint on x86).
+   Unlike this implementation, hardware will also honor the FPU rounding mode.
+*/
+
+static inline double rint(double x)
+{
+  double f, i;
+  f = modf(x, &i);
+  /*
+    All doubles with absolute values > MAX_EXACT_INTEGER are even anyway,
+    no need to check it.
+  */
+  if (x > 0.0)
+    i += (double) ((f > 0.5) || (f == 0.5 &&
+                                 i <= (double) MAX_EXACT_INTEGER &&
+                                 (longlong) i % 2));
+  else
+    i -= (double) ((f < -0.5) || (f == -0.5 &&
+                                  i >= (double) -MAX_EXACT_INTEGER &&
+                                  (longlong) i % 2));
+  return i;
+}
+#endif /* HAVE_RINT */
+
+/* 
+  MYSQL_PLUGIN_IMPORT macro is used to export mysqld data
+  (i.e variables) for usage in storage engine loadable plugins.
+  Outside of Windows, it is dummy.
+*/
+#ifndef MYSQL_PLUGIN_IMPORT
+#if (defined(_WIN32) && defined(MYSQL_DYNAMIC_PLUGIN))
+#define MYSQL_PLUGIN_IMPORT __declspec(dllimport)
+#else
+#define MYSQL_PLUGIN_IMPORT
+#endif
+#endif
+
+/* Defines that are unique to the embedded version of MySQL */
+
+#ifdef EMBEDDED_LIBRARY
+
+/* Things we don't need in the embedded version of MySQL */
+/* TODO HF add #undef HAVE_VIO if we don't want client in embedded library */
+
+#undef HAVE_OPENSSL
+#undef HAVE_SMEM				/* No shared memory */
+
+#endif /* EMBEDDED_LIBRARY */
+
+#endif /* nova_global_h */
diff -uprN libslave-future/Slave.cpp libslave/Slave.cpp
--- libslave-future/Slave.cpp	2012-01-31 05:56:20.000000000 -0800
+++ libslave/Slave.cpp	2013-04-22 00:36:27.000000000 -0700
@@ -309,15 +309,15 @@ struct raii_mysql_connector
             throw std::runtime_error("Slave::reconnect() : mysql_init() : could not initialize mysql structure");
         }
 
-        unsigned int timeout = 60;
+        const char * timeout = "60";
 
-        mysql_options(mysql, MYSQL_OPT_CONNECT_TIMEOUT, &timeout); //(const char*) slave_net_timeout.c_str());
+        mysql_options(mysql, MYSQL_OPT_CONNECT_TIMEOUT, timeout); //(const char*) slave_net_timeout.c_str());
 
         /* Timeout for reads from server (works only for TCP/IP connections, and only for Windows prior to MySQL 4.1.22).
          * You can this option so that a lost connection can be detected earlier than the TCP/IP
          * Close_Wait_Timeout value of 10 minutes. Added in 4.1.1.
          */
-        mysql_options(mysql, MYSQL_OPT_READ_TIMEOUT, &timeout); //(const char*) slave_net_timeout.c_str());
+        mysql_options(mysql, MYSQL_OPT_READ_TIMEOUT, timeout); //(const char*) slave_net_timeout.c_str());
 
         bool was_error = false;
         while (mysql_real_connect(mysql,
@@ -607,7 +607,7 @@ void Slave::register_slave_on_master(MYS
     int4store(pos, 0);
     pos+= 4;
 
-    if (simple_command(mysql, COM_REGISTER_SLAVE, buf, (size_t) (pos-buf), 0)) {
+    if (simple_command(mysql, COM_REGISTER_SLAVE, (const char*)buf, (size_t) (pos-buf), 0)) {
 
         LOG_ERROR(log, "Unable to register slave.");
         throw std::runtime_error("Slave::register_slave_on_master(): Error registring on slave: " +
@@ -837,7 +837,7 @@ void Slave::request_dump(const std::stri
 
     memcpy(buf + 10, logname.data(), logname_len);
 
-    if (simple_command(mysql, COM_BINLOG_DUMP, buf, logname_len + 10, 1)) {
+    if (simple_command(mysql, COM_BINLOG_DUMP, (const char *)buf, logname_len + 10, 1)) {
 
         LOG_ERROR(log, "Error sending COM_BINLOG_DUMP");
         throw std::runtime_error("Error in sending COM_BINLOG_DUMP");
diff -uprN libslave-future/Slave.h libslave/Slave.h
--- libslave-future/Slave.h	2012-01-31 05:56:20.000000000 -0800
+++ libslave/Slave.h	2013-04-22 00:49:23.000000000 -0700
@@ -36,6 +36,7 @@
 namespace slave
 {
 
+static EmptyExtState dummy_state;
 
 class Slave
 {
@@ -70,7 +71,7 @@ public:
 	
     Slave(ExtStateIface &state) : ext_state(state) {}
 
-    Slave(MasterInfo& _master_info, ExtStateIface &state) : m_master_info(_master_info), ext_state(state) {}
+    Slave(MasterInfo& _master_info, ExtStateIface &state = dummy_state) : m_master_info(_master_info), ext_state(state) {}
 
     void setMasterInfo(const MasterInfo& aMasterInfo) { m_master_info = aMasterInfo; }
     const MasterInfo& masterInfo() const { return m_master_info; }
diff -uprN libslave-future/slave_log_event.cpp libslave/slave_log_event.cpp
--- libslave-future/slave_log_event.cpp	2012-01-31 05:56:20.000000000 -0800
+++ libslave/slave_log_event.cpp	2013-04-22 00:44:08.000000000 -0700
@@ -18,6 +18,8 @@
 #include <set>
 
 #include <mysql/my_global.h>
+#include "nova_global.h"
+
 #undef min
 #undef max
 
diff -uprN libslave-future/test/test.cpp libslave/test/test.cpp
--- libslave-future/test/test.cpp	2012-01-31 05:56:20.000000000 -0800
+++ libslave/test/test.cpp	2013-04-22 00:45:42.000000000 -0700
@@ -148,7 +148,7 @@ int main(int argc, char** argv) {
     masterinfo.user = user;
     masterinfo.password = password;
 
-    masterinfo.master_info_file = "libslave.master_info";
+    //masterinfo.master_info_file = "libslave.master_info";
 
     try {
 
